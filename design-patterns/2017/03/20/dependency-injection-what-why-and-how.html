<p>We are going to explore dependency injection with emphasis on swift iOS development. But the concept
applies to most object oriented languages. We will also see some practical considerations on 
applying DI in iOS environment. This article is result of my deep dive into implementing DI, and learning about 
various practical, theoretical aspects of it.</p>

<h1 id="what-is-dependency-injection">What is Dependency Injection?</h1>

<blockquote>
  <p>“Dependency Injection” is a 25-dollar term for a 5-cent concept”.</p>
</blockquote>

<p>is a often repeated maxim regarding DI.</p>

<p>In its essence DI means wherever possible, <strong>replace object creation inside a piece of code 
by providing it from outside that piece of code</strong>. Hence the term.</p>

<p>Constructor, Property, Method are where we usually do object creation, and that can be replaced from outside. So we end up with 3 types of injection.</p>

<ol>
  <li>Constructor Injection</li>
  <li>Property Injection</li>
  <li>Method Injection</li>
</ol>

<p>We will explore they 3 types in “How ..?” section.</p>

<h1 id="why-dependency-injection">Why Dependency Injection?</h1>

<p>Let’s dwelve into this with help of a scenario.</p>

<h2 id="scenario---koala-koder">Scenario - Koala Koder!</h2>

<p>Say you have an app with a user login. A user model struct/class  encapsulates the logged in user data.</p>

<p>Suppose you are a Koala Koder( a programmer who is as lazy as a koala bear). You perhaps made a solution which is quick and dirty. Store the user model inside NSUserDefaults, and fetch it via properties. And as we all know how apple loves its singleton classes, we follow them making UserModel a singleton.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">UserModel</span> <span class="p">{</span>

    <span class="kd">static</span> <span class="k">let</span> <span class="nv">sharedInstance</span> <span class="o">=</span> <span class="kt">UserModel</span><span class="p">()</span>

    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kt">NSUserDefaults</span><span class="o">.</span><span class="n">standard</span><span class="o">.</span><span class="nf">string</span><span class="p">(</span><span class="nv">forKey</span><span class="p">:</span> <span class="s">"userName"</span><span class="p">)</span>  <span class="p">??</span> <span class="s">""</span>
        <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span>
            <span class="kt">NSUserDefaults</span><span class="o">.</span><span class="n">standard</span><span class="o">.</span><span class="nf">set</span><span class="p">(</span><span class="n">newValue</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span><span class="s">"userName"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">greet</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"</span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">, Vannakam :)"</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>We write our app with this usermodel in mind, and <code class="highlighter-rouge">UserModel.sharedInstance</code> is everywhere in our app.</p>

<p><img src="https://ih0.redbubble.net/image.5150955.4141/flat,1000x1000,075,f.jpg" alt="Koala lazing off" /></p>

<h2 id="problems-problems-everywhere">Problems, problems everywhere…</h2>

<h3 id="1-unit-tester-vader-strikes">1. Unit Tester Vader strikes!</h3>

<p>A senior developer suddenly turns to the dark side, and starts ranting about <em>unit testing</em>.
He/She will not let apps which are not unit tested pass the code review.</p>

<p><img src="http://s2.quickmeme.com/img/03/0347c3efdc17cc1959d089f60b8b2fc267d9093caa8e8cb483bf476b58e63e45.jpg" alt="Meme: Darth Vader says &quot;I find your lack of unit testing disturbing&quot;" /></p>

<h3 id="2-a-wild-new-use-case-appears">2. A wild New Use case appears!</h3>

<p>And if that isn’t enough a <em>new use case</em>  should be supported. Our app should now support <em>multiple users</em>.</p>

<p><img src="https://cdn.meme.am/instances/500x/64312241.jpg" alt="Meme: Back to future - Dr Brown says &quot;New Usecase in no time? I've an extra flux capacitor&quot;" /></p>

<h3 id="3-lets-move-to-insert-any-serialization-library-here">3. “Lets move to &lt;insert any serialization library here&gt;”</h3>

<p>Now we also reached a point where userdefaults didn’t scale and  wish to migrate to new data serialization method. Now even our getters and setters inside the UserProfile is not safe.</p>

<h2 id="why-are-there-problems">Why are there problems?</h2>

<p>So we find ourselves in deep trouble. Lets analyze why so.</p>

<h3 id="1-singletons-are-hard-to-test">1. Singletons are hard to test</h3>

<p>Now if you want to unit test a viewcontroller that uses this singleton.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">class</span> <span class="kt">UserProfile</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">greetingLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="kt">UserModel</span><span class="o">.</span><span class="n">sharedInstance</span><span class="o">.</span><span class="nf">greet</span><span class="p">()</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>In unit testing you create a UserProfile object, call viewDidLoad or other methods manually. Now you have to verify 
whether <code class="highlighter-rouge">UserModel.sharedInstance.greet()</code> was called.</p>

<p>Since UserModel.sharedInstance is immutable, either we can’t replace it with our mock class extending UserModel, which overrides greetUser, and sets a flag which can be checked. So our testing coverage comes down.</p>

<h3 id="2-instantiation-inside-our-code-constraints-creates-strong-coupling-creating-harmful-constraints">2. Instantiation inside our code constraints creates strong coupling, creating harmful constraints</h3>

<p>In our scenario, by using a singleton, we tied our codebase to a single UserModel but now our app needs multiple user models. So in general, using singletons will make it hard to adapt to new use cases. <em>What you thought as a singleton suddenly is not so single anymore</em>.</p>

<p>But consider that we didn’t use singleton, but instantiated UserModel, by calling <code class="highlighter-rouge">UserModel()</code> wherever we needed it.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">class</span> <span class="kt">UserProfile</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="k">let</span> <span class="nv">userModel</span> <span class="o">=</span> <span class="kt">UserModel</span><span class="p">()</span>

    <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">userNameLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">userModel</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>We can’t support our new usecase of multiple users, without userprofile class knowing about multi-usermodel, or some other global allowing UserModel() to return the correct usermodel, these solutions are ugly hacks, which add complexity by either giving too much knowledge to classes or using globals and forgoing object oriented encapsulation.</p>

<h3 id="3-concrete-type-usage-creates-strong-coupling">3. Concrete Type usage creates strong coupling</h3>

<p>Consider the UserProfile, it  uses NSUserDefaults, now suppose we move to coredata to save our data, we are again in trouble because of using singleton inside. <strong>Our UserProfile rather needed only just a way to serialize some data, it didn’t need to know about WHAT we use for serialization</strong>. This is the key insight to keep in mind  when thinking about dependency injection.</p>

<h2 id="di-to-the-rescue">DI to the rescue</h2>

<p>DI helps to solve the variety of issues that we face above, with regard to  Unit Testablity, Singletons and strong coupling we face above.</p>

<h1 id="how-to-do-dependency-injection">How to do Dependency Injection?</h1>

<h2 id="constructor-injection">Constructor Injection</h2>

<p>So we will be injecting a serializer into UserModel via constructor.</p>

<p><strong>Move dependency to constructor, and if possible make it a interface/protocol type instead of concrete class/struct</strong></p>

<p>So we remove singleton access to userdefaults. And rather pass a serializer protocol which has methods we require for serialization to constructor.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">protocol</span> <span class="kt">Serializing</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">string</span><span class="p">(</span><span class="n">forKey</span> <span class="n">defaultName</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">set</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Any</span><span class="p">?,</span> <span class="n">forKey</span> <span class="n">defaultName</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">UserModel</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">serializer</span><span class="p">:</span> <span class="kt">Serializing</span>

    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">serializer</span><span class="p">:</span> <span class="kt">Serializing</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">serializer</span> <span class="o">=</span> <span class="n">serializer</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">serializer</span><span class="o">.</span><span class="nf">string</span><span class="p">(</span><span class="nv">forKey</span><span class="p">:</span> <span class="s">"userName"</span><span class="p">)</span>  <span class="p">??</span> <span class="s">""</span>
         <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span>
            <span class="n">serializer</span><span class="o">.</span><span class="nf">setObject</span><span class="p">(</span><span class="n">newValue</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span><span class="s">"userName"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>

</code></pre></div></div>

<p>Since we are Koala Koder, we just make the Serializing protocol methods to same ones in NSUserdefaults, so we can make NSUserDefaults conform easily by</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">NSUserDefaults</span><span class="p">:</span> <span class="kt">Serializing</span> <span class="p">{}</span>
</code></pre></div></div>
<p>.</p>

<p>Now to use user defaults as our serializer, we do the following.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">UserModel</span><span class="p">(</span><span class="nv">serializer</span><span class="p">:</span> <span class="kt">NSUserDefaults</span><span class="o">.</span><span class="n">standard</span><span class="p">)</span>
</code></pre></div></div>

<p>For our fancy multiple user use case we can also do this. (Note: did this in a hurry, it may have edge cases, just providing it as a illustration)</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">struct</span> <span class="kt">MultiUserSerializer</span><span class="p">:</span> <span class="kt">Serializing</span> <span class="p">{</span>

    <span class="k">let</span> <span class="nv">serializer</span><span class="p">:</span> <span class="kt">Serializing</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">serializer</span><span class="p">:</span> <span class="kt">Serializing</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">serializer</span> <span class="o">=</span> <span class="n">serializer</span>
    <span class="p">}</span>

    <span class="c1">// So we fetch the current currentUserId and use that to prefix stored data</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">fetchCurrentUserId</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">serializer</span><span class="o">.</span><span class="nf">string</span><span class="p">(</span><span class="nv">forKey</span><span class="p">:</span> <span class="s">"CURRENT_USER_ID"</span><span class="p">)</span> <span class="p">??</span> <span class="s">"0"</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">string</span><span class="p">(</span><span class="n">forKey</span> <span class="n">defaultName</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">serializer</span><span class="o">.</span><span class="nf">string</span><span class="p">(</span><span class="nv">forKey</span><span class="p">:</span> <span class="nf">fetchCurrentUserId</span><span class="p">()</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="n">defaultName</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">set</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Any</span><span class="p">?,</span> <span class="n">forKey</span> <span class="n">defaultName</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">serializer</span><span class="o">.</span><span class="nf">set</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">forKey</span> <span class="n">defaultName</span><span class="p">:</span> <span class="nf">fetchCurrentUserId</span><span class="p">()</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="n">defaultName</span><span class="p">)</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">//Instantiate using userdefaults, assume we implemented contextFetcher somewhere else</span>

<span class="k">let</span> <span class="nv">multiUserSerializer</span> <span class="o">=</span> <span class="kt">MultiUserSerializer</span><span class="p">(</span><span class="nv">serializer</span><span class="p">:</span> <span class="kt">NSUserDefaults</span><span class="o">.</span><span class="n">standard</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">userModel</span> <span class="o">=</span> <span class="kt">UserModel</span><span class="p">(</span><span class="nv">serializer</span><span class="p">:</span> <span class="n">multiUserSerializer</span><span class="p">)</span>

</code></pre></div></div>

<p>So now userModel fetches data, and sets data to the current userID without even knowing about it. We could also use something other than <code class="highlighter-rouge">NSUserDefaults.standard</code> to serialize the data in top level.</p>

<p>The point is by removing replacing the concrete  dependency <code class="highlighter-rouge">NSUserDefaults.standard</code> out of <code class="highlighter-rouge">UserModel</code> and swapping it to <code class="highlighter-rouge">Serializing</code> protocol we can now satisfy the new usecase of multi user modelling easily. This is the core idea behind of <strong>loose coupling</strong>.</p>

<p>Also we can now unit test User Model by just passing a Mock implementation of <code class="highlighter-rouge">Serializing</code></p>

<h3 id="dependency-injection-works-even-with-only-concrete-types">Dependency injection works even with only concrete types.</h3>

<p>Sometimes you don’t have the time, or are  sure that concrete type used will not have to be changed. You can still DI the concrete type without bothering with protocol creation, just for the sake of it.</p>

<h4 id="for-example">For example:</h4>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">class</span> <span class="kt">UserProfile</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="k">let</span> <span class="nv">userModel</span><span class="p">:</span> <span class="kt">UserModel</span>

    <span class="c1">// This works only if you don't use storyboards</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">userModel</span><span class="p">:</span> <span class="kt">UserModel</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">userModel</span> <span class="o">=</span> <span class="n">userModel</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">userNameLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">userModel</span><span class="o">.</span><span class="n">name</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>We  move UserModel creation out of the controller, without creating any protocol for UserModel properties.</p>

<p>We still gain advantages of unit testability using ordinary mock objects, and also we are free to use our multi user serialized UserModel , hence making UserProfile support multi user model without changing any logic in user profile.</p>

<p>(But if you have to do something to notify changes in data, that is seperate topic)</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">multiUserSerializer</span> <span class="o">=</span> <span class="kt">MultiUserSerializer</span><span class="p">(</span><span class="nv">serializer</span><span class="p">:</span> <span class="kt">NSUserDefaults</span><span class="o">.</span><span class="n">standard</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">multiUserModel</span> <span class="o">=</span> <span class="kt">UserModel</span><span class="p">(</span><span class="nv">serializer</span><span class="p">:</span> <span class="n">multiUserSerializer</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">userProfile</span> <span class="o">=</span> <span class="kt">UserProfile</span><span class="p">(</span><span class="nv">userModel</span><span class="p">:</span> <span class="n">multiUserModel</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="my-constructor-is-a-monster-now">My constructor is a monster now :(</h3>

<p>A common problem which you will come across is, your UIViewController (if you don’t use storyboards) or any class where you do DI becomes a to big.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">UserProfile</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

<span class="nf">init</span><span class="p">(</span><span class="nv">userModel</span><span class="p">:</span> <span class="kt">UserModel</span><span class="p">,</span> <span class="nv">apiService</span><span class="p">:</span> <span class="kt">APIService</span><span class="p">,</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">XService</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span><span class="kt">YService</span><span class="p">,</span> <span class="nv">z</span><span class="p">:</span> <span class="kt">ZService</span><span class="p">,</span> <span class="o">....</span><span class="p">)</span> 
</code></pre></div></div>

<p>This is a good thing, it points out clearly that your class is violating <strong>Single Responsibility rule</strong> . Single responsibility rule states that a  class should have singe responsibility.</p>

<p>We can solve this by moving some of the current dependencies to a new class, and pass the new class as dependency to UserProfile.</p>

<p>Guess what if we do this we properly we would be re-inventing design patterns l
MVVM(Nodel View ViewModel) or MVP. Whew! DI just solved Huge ViewController problem!!.</p>

<blockquote>
  <p>DI can easily help refactoring code to better design, in a gradual manner.</p>
</blockquote>

<h2 id="property-injection">Property Injection</h2>

<p>We seemed to have solved all our above problems, why bother with more types of injections?</p>

<blockquote>
  <p>If you don’t control the creation of a object, your best bet is property injection. But prefer constructor injection if that’s not the case.</p>
</blockquote>

<p>Sometimes you don’t create objects of classes, some messy framework does it. For example, if you use Storyboards, you can’t do stuff like <code class="highlighter-rouge">let userProfileViewController = UserProfile(multiUserModel)</code>. You would have to refactor to something like</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">class</span> <span class="kt">UserProfile</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="k">var</span> <span class="nv">userModel</span><span class="p">:</span> <span class="kt">UserModel</span><span class="o">!</span>

    <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">userNameLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">userModel</span><span class="o">.</span><span class="n">name</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">multiUserSerializer</span> <span class="o">=</span> <span class="kt">MultiUserSerializer</span><span class="p">(</span><span class="nv">serializer</span><span class="p">:</span> <span class="kt">NSUserDefaults</span><span class="o">.</span><span class="n">standard</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">multiUserModel</span> <span class="o">=</span> <span class="kt">UserModel</span><span class="p">(</span><span class="nv">serializer</span><span class="p">:</span> <span class="n">multiUserSerializer</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">storyboard</span> <span class="o">=</span> <span class="kt">UIStoryboard</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"main"</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">userProfile</span> <span class="o">=</span> <span class="n">storyboard</span><span class="o">.</span><span class="nf">instantiateViewController</span><span class="p">(</span><span class="nv">withIdentifier</span><span class="p">:</span> <span class="s">"UserProfile"</span><span class="p">)</span> <span class="k">as!</span> <span class="kt">UserProfile</span>
<span class="n">userProfile</span><span class="o">.</span><span class="n">userModel</span> <span class="o">=</span> <span class="n">multiUserModel</span>

</code></pre></div></div>

<p>By using implicitly unwrapped Optional property, and setting it from outside, we achive the same effects of constructor injection. But is not perfect, as <code class="highlighter-rouge">userModel</code> property can be mutated from outside. Butthis is as good as it can get.</p>

<h2 id="method-injection">Method Injection</h2>

<p>Method injection is just replacing instantiating inside method by one of its parameters.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Before injection</span>

<span class="kd">func</span> <span class="nf">someMethod</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="kt">X</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="nf">something</span><span class="p">()</span> <span class="o">+</span> <span class="mi">10</span>
    <span class="k">return</span> <span class="n">y</span>
<span class="p">}</span>

<span class="c1">// After injection</span>

<span class="kd">func</span> <span class="nf">someMethod</span><span class="p">(</span><span class="n">_</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">XService</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="nf">something</span><span class="p">()</span> <span class="o">+</span> <span class="mi">10</span>
    <span class="k">return</span> <span class="n">y</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="runtime-injection---factory-pattern">Runtime Injection - Factory pattern</h2>

<p>Sometimes you want to create a object of a particular class in runtime. But you want to use only protocol type(or a super type) instead of actual implementation (or subclass). Let’s say you need a networking service, which you set based on a user action, but as you are going to need it in runtime, you may think that you can’t inject it.</p>

<p>But what you can do is inject a factory Networking object or closure, that constructs it in runtime. This factory can fill the dependency of the concrete Networking class, so your class can be unaware of this.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">protocol</span> <span class="kt">Networking</span> <span class="p">{</span>
 <span class="c1">// Some methods ..</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">ProxyNetworking</span><span class="p">:</span> <span class="kt">Networking</span>  <span class="p">{</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="kt">A</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">NormalNetworking</span><span class="p">:</span> <span class="kt">Networking</span> <span class="p">{</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="kt">A</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// Injection Via Factory Class</span>

<span class="kd">class</span> <span class="kt">NetworkingFactory</span> <span class="p">{</span>

    <span class="k">let</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">A</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="kt">A</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="kt">A</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">create</span><span class="p">(</span><span class="n">_</span> <span class="nv">withProxy</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Networking</span> <span class="p">{</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">withProxy</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kt">ProxyNetworking</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="n">a</span><span class="p">)</span>
         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kt">NormalNetworking</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="n">a</span><span class="p">)</span>
         <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kd">class</span> <span class="kt">Some</span> <span class="p">:</span><span class="kt">UIViewController</span> <span class="p">{</span>

  <span class="c1">// This has to be injected via property injection</span>
    <span class="k">var</span> <span class="nv">networkingFactory</span><span class="p">:</span> <span class="kt">NetworkingFactory</span><span class="o">!</span> 

    <span class="k">var</span> <span class="nv">networking</span><span class="p">:</span> <span class="kt">Networking</span><span class="p">?</span>

    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">proxySwitch</span><span class="p">:</span> <span class="kt">UISwitch</span><span class="o">!</span>

    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">userTappedSubmit</span><span class="p">(</span><span class="nv">sender</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">networking</span> <span class="o">=</span> <span class="n">networkingFactory</span><span class="o">.</span><span class="nf">create</span><span class="p">(</span><span class="nv">withProxy</span><span class="p">:</span> <span class="n">proxySwitch</span><span class="o">.</span><span class="n">isOn</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// Injection using closure</span>

<span class="kd">class</span> <span class="kt">Some</span> <span class="p">:</span><span class="kt">UIViewController</span> <span class="p">{</span>

    <span class="c1">// This has to be injected via property injection</span>
    <span class="k">var</span> <span class="nv">networkingFactory</span><span class="p">:</span> <span class="p">((</span><span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Networking</span><span class="p">)</span><span class="o">!</span>

    <span class="k">var</span> <span class="nv">networking</span><span class="p">:</span> <span class="kt">Networking</span><span class="p">?</span>

    <span class="kd">@IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">proxySwitch</span><span class="p">:</span> <span class="kt">UISwitch</span><span class="o">!</span>

    <span class="kd">@IBAction</span> <span class="kd">func</span> <span class="nf">userTappedSubmit</span><span class="p">(</span><span class="nv">sender</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">networking</span> <span class="o">=</span> <span class="nf">networkingFactory</span><span class="p">(</span><span class="n">proxySwitch</span><span class="o">.</span><span class="n">isOn</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>


</code></pre></div></div>

<h1 id="dependency-injection---containers--frameworks">Dependency injection - Containers &amp; Frameworks</h1>

<p>There are Dependency Injection frameworks that make the job of dependency injection easier. You may say, “whoa Sai! wait,Do we really need a dependency injection framework as a dependency? Can’t it be done “.</p>

<p>When we examine what we are doing with DI, we are building a graph with our concrete types as nodes, and their dependencies linking them. If we do this completely, all dependencies will originate from a root object.</p>

<p>Without a framework, we will be doing a lot of copy paste coding. If our app uses networking protocol type in multiple areas, we have to type out the same concrete implementation everywhere, and fill out every dependency of networking class everywhere.</p>

<p>For example:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">class</span> <span class="kt">A</span> <span class="p">{</span> 
    <span class="k">var</span> <span class="nv">propertyInjectionVar</span> <span class="p">:</span><span class="kt">V</span><span class="o">!</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">networking</span><span class="p">:</span> <span class="kt">Networking</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> 
  <span class="p">}</span>

 <span class="c1">// To create A we have to create networking and also fill out any property injection vars it needs</span>

 <span class="kd">class</span> <span class="kt">NetworkService</span><span class="p">:</span> <span class="kt">Networking</span> <span class="p">{</span> <span class="nf">init</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="kt">X</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Y</span><span class="p">,</span> <span class="nv">z</span><span class="p">:</span> <span class="kt">Z</span><span class="p">)</span> <span class="p">{}</span> <span class="p">}</span>

 <span class="c1">// Now networking will inturn have its dependencies , which inturn have more ..</span>
 <span class="c1">// So to create A, You have to create NetworkService, X, Y, Z </span>

<span class="kt">A</span><span class="p">(</span><span class="n">networking</span> <span class="kt">NetworkService</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="kt">X</span><span class="p">(),</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Y</span><span class="p">(),</span> <span class="nv">z</span><span class="p">:</span> <span class="kt">Z</span><span class="p">()))</span>

</code></pre></div></div>

<p>To make this process easier we can build something to store list of dependency type, and their concrete implementation. We will have a table of mappings.</p>

<table>
  <thead>
    <tr>
      <th>Dependency Type</th>
      <th>Implementation type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Networking</td>
      <td>NetworkService</td>
    </tr>
    <tr>
      <td>X</td>
      <td>XService</td>
    </tr>
    <tr>
      <td>Y</td>
      <td>YService</td>
    </tr>
    <tr>
      <td>Z</td>
      <td>ZSubClass</td>
    </tr>
    <tr>
      <td>A</td>
      <td>A</td>
    </tr>
  </tbody>
</table>

<p>We can register a protocol Dependency Type to concrete implementation, like Networking, X, Y to NetworkService, XService, YService respectively. Or map concrete type to its concrete implementation which can be exactly same type, like A, or subclass like mapping Z to ZSubClass. Now what the container does is when A has to be created, it auto resolves each dependency of A from the table.</p>

<p>You can either implement a container, or use a DI Framework which does that for you.</p>

<p>Containers also allow you to autofill property injection, handle lifecycle of dependencies like marking them as singleton, so that your whole container has only one object of that type created and other fancy features to make your life easy.</p>

<blockquote>
  <h3 id="a-key-point-to-remember-is-that-your-classes-should-not-depend-on-di-framework-container-ie-its-not-good-idea-to-pass-the-container-to-your-class-as-a-dependency">A key point to remember is that your classes should not depend on DI framework container ie its not good idea to pass the container to your class as a dependency.</h3>
</blockquote>

<h2 id="dip-framework---swift"><a href="https://github.com/AliSoftware/Dip">Dip Framework - Swift</a></h2>

<p>Among the DI frameworks exiting now for swift, I recommend Dip. Dip has some nifty features to make your DI pain free.</p>

<h3 id="features-of-dip">Features of Dip</h3>

<ul>
  <li><strong>Scopes</strong>. Dip supports 5 different scopes (or life cycle strategies): <em>Unique</em>, <em>Shared</em>, <em>Singleton</em>, <em>EagerSingleton</em>, <em>WeakSingleton</em>;</li>
  <li><strong>Auto-wiring</strong> &amp; <strong>Auto-injection</strong>. Dip can infer your components’ dependencies injected in constructor and automatically resolve them as well as dependencies injected with properties.</li>
  <li><strong>Resolving optionals</strong>. Dip is able to resolve constructor or property dependencies defined as optionals.</li>
  <li><strong>Type forwarding</strong>. You can register the same factory to resolve different types implemeted by a single class.</li>
  <li><strong>Circular dependencies</strong>. Dip will be able to resolve circular dependencies if you will follow some simple rules;</li>
  <li><strong>Storyboards integration</strong>. You can easily use Dip along with storyboards and Xibs without ever referencing container in your view controller’s code;</li>
  <li><strong>Named definitions</strong>. You can register different factories for the same protocol or type by registering them with <a href="">tags</a>;</li>
  <li><strong>Runtime arguments</strong>. You can register factories that accept up to 6 runtime arguments (and extend it if you need);</li>
  <li><strong>Easy configuration</strong> &amp; <strong>Code generation</strong>. No complex containers hierarchy, no unneeded functionality. Tired of writing all registrations by hand? There is a <a href="https://github.com/ilyapuchka/dipgen">cool code generator</a> that will create them for you. The only thing you need is to annotate your code with some comments.</li>
  <li><strong>Weakly typed components</strong>. Dip can resolve “weak” types when they are unknown at compile time.</li>
  <li><strong>Thread safety</strong>. Registering and resolving components is thread safe;</li>
  <li><strong>Helpful error messages and configuration validation</strong>. You can validate your container configuration. If something can not be resolved at runtime Dip throws an error that completely describes the issue;</li>
</ul>

<h3 id="annotations-in-dip">Annotations in Dip</h3>

<p>Java has good frameworks like <a href="https://square.github.io/dagger/">Dagger</a>, and <a href="https://github.com/google/guice">Guice</a> that use annotations to make the job even simpler compared to swift. Dip allows you to leave annotations of dependencies in comments and also generate code for DI from it. How cool is that?</p>

<h2 id="poor-mans-di-in-swift">Poor man’s DI in Swift</h2>

<p>Though I recommend the framework approach, supposing you don’t want to use framework initially and still want the to do DI, Fear not. You can use Swift’s default parameters to do constructor/method injection, and just use variable properties for property injection. You can maintain a Seperate DI singleton and fill dependencies using that.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="kd">class</span> <span class="kt">UserModel</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">serializer</span><span class="p">:</span> <span class="kt">Serializing</span>

    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">serializer</span><span class="p">:</span> <span class="kt">Serializing</span> <span class="o">=</span> <span class="kt">PoormanDIContainer</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="nf">getSerializer</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// Poor man DI</span>
        <span class="k">self</span><span class="o">.</span><span class="n">serializer</span> <span class="o">=</span> <span class="n">serializer</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">serializer</span><span class="o">.</span><span class="nf">string</span><span class="p">(</span><span class="nv">forKey</span><span class="p">:</span> <span class="s">"userName"</span><span class="p">)</span>  <span class="p">??</span> <span class="s">""</span>
         <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span>
            <span class="n">serializer</span><span class="o">.</span><span class="nf">setObject</span><span class="p">(</span><span class="n">newValue</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span><span class="s">"userName"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kd">class</span> <span class="kt">PoorManDIContainer</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">instance</span> <span class="o">=</span> <span class="kt">PoorManDIContainer</span><span class="p">()</span> 
    <span class="kd">func</span> <span class="nf">getSerializer</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Serializing</span> <span class="p">{</span>
        <span class="c1">// If Serializer has some dependencies, it will again use default constructor to obtain it from PoorManDIContainer</span>
        <span class="k">return</span> <span class="kt">Serializer</span><span class="p">()</span> 
    <span class="p">}</span>
<span class="p">}</span>


</code></pre></div></div>

<p>But if you use the above method, beware of circular dependencies.</p>

<h1 id="conclusion">Conclusion</h1>

<p>So in conclusion DI is great. It allows you to progressively make your code better remove  singletons, make your code modular, testable and also allow you to evolve good design patterns. Try it out in your existing code base, it will be one of the easiest way to refactor legacy OOP code, without modifying internal logic initially.If you have any doubts, suggestions, constructive criticisms, comment below.</p>
